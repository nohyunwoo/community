# 1. 동시성 이슈로 인한 좋아요 수 반영 오류
  <**문제상황**>
    게시글에 좋아요를 누르면 서버에서 해당 게시글의 좋아요 수를 증가시키는 로직을 구현하였습니다. 
    하지만 동시에 여러 사용자가 같은 게시글에 좋아요를 누를 경우, 
    일부 요청이 무시되어 기대했던 좋아요 수보다 적게 증가하는 현상이 발생하였습니다.
  
  <**테스트**>
    - 도구: Apache JMeter
    - 시나리오: 100명의 사용자가 동시에 하나의 게시글에 좋아요 요청 전송
    - 예상 결과 : 좋아요 수가 정확히 100 증가
    - 실제 결과: 좋아요 수가 100 미만으로 반영됨
  
  <**원인 분석 및 추정**>
    * 다수의 요청이 동시에 동일한 게시글 데이터를 조회하고 수정하면서 **Race Condition** 발생

  <**해결방법**>
  - 비관적 락(Pessimistic Lock)
    * 데이터를 조회할 때부터 해당 데이터에 락을 걸어 다른 트랜잭션이 접근하지 못하게 함.
    * 장점: 동시성 충돌을 사전에 방지하므로 데이터 정합성이 높음
  - 낙관적 락(Optimistic Lock)
    * 데이터를 읽을 때는 락을 걸지 않고, 수정 시점에 버전 정보를 확인하여 충돌을 감지함.
    * 장점: 락을 사용하지 않기에 데드락 발생 없음
  - 네임드 락(Named Lock)
    * 논리적인 이름 기반으로 락을 설정함.
    * 장점: 레코드 단위로 락을 걸기 어려운 경우 유용
  
  <**문제점 및 보완**>
  - 비관적 락
    * 단점
      * 트랜잭션 동안 락을 유지하므로 데드락이나 성능 저하 우려
      * 동시 요청 수가 많을수록 대기 시간 증가
  - 낙관적 락
      * 단점
          * 충돌 발생 시 예외가 발생하며, 재시도 로직 필요
          * 변경이 자주 발생하는 상황에서는 실패율이 높아질 수 있음
  - 네임드 락
      * 단점
          * DB나 외부 시스템에 의존도 증가
          * 락 해제가 누락되면 락이 영구적으로 유지될 위험 존재
  * Lock 기반의 동시성 제어 방식(비관적 락, 낙관적 락, 네임드 락)은 데이터 정합성 확보에는 유리하지만,
    다수의 트랜잭션이 동시에 접근할 경우 성능 저하나 병목 현상이 발생할 수 있다는 문제점이 있음.
  * post_like 테이블로 분리 및 Redis 캐시 방식으로 보완

  <**보완 후 테스트**>
  - 도구: Apache JMeter
  - 시나리오: 100명의 사용자가 동시에 하나의 게시글에 좋아요 요청 전송
  - 예상 결과 : 좋아요 수가 정확히 100 증가
  - 실제 결과: post_like에 좋아요 수가 100개 생성 및 Redis에서 중복을 방지하여 캐시 100개 확인

  <**결과**>
  * 커뮤니티 사이트는 트래픽이 집중될 수 있는 서비스이기 때문에, 락 기반 처리 방식은 병목과 성능 저하를 
    유발할 가능성이 높아 응답 속도와 처리량이 더욱 중요합니다. 이에 따라, 락을 사용하지 않고 좋아요 테이블 분리
    및 Redis 캐시를 적용하여 성능 저하를 최소화하고 병목 현상을 방지하며, 동시에 데이터 정합성과 동시성 문제를 효과적으로 해결하였습니다.
