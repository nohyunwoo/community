# 1. 동시성 이슈로 인한 좋아요 수 반영 오류
### 문제상황
* 게시글에 좋아요를 누르면 서버에서 해당 게시글의 좋아요 수를 증가시키는 로직을 구현하였습니다. 
  하지만 동시에 여러 사용자가 같은 게시글에 좋아요를 누를 경우, 일부 요청이 무시되어 기대했던 좋아요 수보다 적게 증가하는 현상이 발생하였습니다.
  
### 테스트
* 도구: Apache JMeter
* 시나리오: 100명의 사용자가 동시에 하나의 게시글에 좋아요 요청 전송
* 예상 결과 : 좋아요 수가 정확히 100 증가
* 실제 결과: 좋아요 수가 100 미만으로 반영됨
  
### 원인 분석 및 추정
* 다수의 요청이 동시에 동일한 게시글 데이터를 조회하고 수정하면서 **Race Condition** 발생

### 해결방법
* 비관적 락(Pessimistic Lock)
  * 데이터를 조회할 때부터 해당 데이터에 락을 걸어 다른 트랜잭션이 접근하지 못하게 함. 
  * 장점: 동시성 충돌을 사전에 방지하므로 데이터 정합성이 높음
* 낙관적 락(Optimistic Lock)
  * 데이터를 읽을 때는 락을 걸지 않고, 수정 시점에 버전 정보를 확인하여 충돌을 감지함.
  * 장점: 락을 사용하지 않기에 데드락 발생 없음
* 네임드 락(Named Lock)
  * 논리적인 이름 기반으로 락을 설정함.
  * 장점: 레코드 단위로 락을 걸기 어려운 경우 유용

### 문제점 및 보완
* 비관적 락 
  * 단점
    * 트랜잭션 동안 락을 유지하므로 데드락이나 성능 저하 우려
    * 동시 요청 수가 많을수록 대기 시간 증가
* 낙관적 락
  * 단점
    * 충돌 발생 시 예외가 발생하며, 재시도 로직 필요 
    * 변경이 자주 발생하는 상황에서는 실패율이 높아질 수 있음
* 네임드 락
  * 단점
    * DB나 외부 시스템에 의존도 증가
    * 락 해제가 누락되면 락이 영구적으로 유지될 위험 존재
    * Lock 기반의 동시성 제어 방식(비관적 락, 낙관적 락, 네임드 락)은 데이터 정합성 확보에는 유리하지만,
    다수의 트랜잭션이 동시에 접근할 경우 성능 저하나 병목 현상이 발생할 수 있다는 문제점이 있음.
    * post_like 테이블로 분리 및 Redis INCR 방식으로 보완

### 보완 후 테스트
* 도구: Apache JMeter
* 시나리오: 100명의 사용자가 동시에 하나의 게시글에 좋아요 요청 전송
* 예상 결과 : 좋아요 수가 정확히 100 증가
* 실제 결과: post_like에 좋아요 수가 100개 생성 및 Redis에서 중복을 방지하여 캐시 100개 확인

### 결과
* 커뮤니티 사이트는 트래픽이 집중될 수 있는 서비스이기 때문에, 락 기반 처리 방식은 병목과 성능 저하를 
유발할 가능성이 높아 응답 속도와 처리량이 더욱 중요합니다. 이에 따라, 락을 사용하지 않고 좋아요 테이블 분리
및 Redis 캐시를 적용하여 성능 저하를 최소화하고 병목 현상을 방지하며, 동시에 데이터 정합성과 동시성 문제를 해결하였습니다.

# 2. 페이지네이션 N+1 문제
### 문제상황
* 커뮤니티 게시판을 개발하면서, 사용자가 게시글 목록을 효율적으로 볼 수 있도록 **페이지네이션** 기능을 구현했습니다.
  그런데 개발 과정에서 JPA의 SQL 쿼리 로그를 확인하던 중 의도하지 않은 쿼리의 반복이 발생하는 것을 발견했습니다.
    
### 원인 분석 및 추정 
* 게시글 목록 조회 (1차 쿼리) 1번 페이지에 표시될 게시글 10개를 가져오는 쿼리가 실행됩니다.
* 전체 게시글 수 조회 (2차 쿼리) 페이지네이션 UI를 위해 전체 게시글 수를 세는 쿼리가 실행됩니다.
* 작성자 정보 조회 (추가 쿼리) 각 게시글에 대한 작성자 정보를 가져오기 위해 게시글 수(10개)만큼 추가적인 쿼리가 반복적으로 발생했습니다.
* 분석: 게시글 10개 중 작성자가 총 3명(1번 사용자 8개, 2번 사용자 1개, 3번 사용자 1개)일 경우, JPA의 1차 캐시 덕분에 동일한 사용자에 대한 중복 쿼리는 발생하지 않지만,
       고유한 사용자 수만큼(3회) 쿼리가 추가로 실행되었습니다.
* 결론: 이는 총 1+1+3 = 5개의 쿼리가 실행되어 비효율적이며 성능 저하를 야기했습니다.

### 해결과정
* N+1 문제 해결을 위해 `EAGER` 타입 변경, `Fetch Join`, `Batch Fetching` 세 가지 방안을 고려했습니다.
  EAGER 타입 변경은 게시글 조회 시 항상 연관된 엔티티를 즉시 로딩하여 불필요한 쿼리를 유발할 수 있으므로 해결책에서 제외했습니다.
  Fetch Join과 Batch Fetching 중, 조회 대상인 Post와 User의 관계는 N:1(@ManyToOne)이었습니다. 이 관계는 페이징 처리 시 데이터 중복 문제를 일으키지 않으므로,
  단 한 번의 쿼리로 모든 데이터를 가져와 네트워크 비용을 최소화할 수 있는 Fetch Join을 최종 해결책으로 선택했습니다.

### 문제점 및 보완
* Fetch Join
  * 연관 관계에 있는 엔티티를 조회할 때, 즉 게시글 목록 조회를 할 때 JOIN 쿼리를 사용해 모든 연관 데이터를 한번에 가져오는 방법이다.
    * 주로 ToOne 관계를 즉시 정보를 가져와야할 때 사용한다.
  *  장점
    * 단 한번의 쿼리로 연관된 모든 데이터를 가져온다.
  * 단점
    * ToMany 관계에서 페이징과 함께 사용하면 데이터가 중복될 수 있는 문제 존재가 있다.
* Batch Fetching
  * 지연 로딩을 최적화하는 방법으로 필요할 때 하나씩 쿼리를 사용해 조회하는 대신 배치 사이즈 만큼 IN을 사용해 함께 조회한다.
  * 장점
    * 페이징이 필요한 @OneToMany 관계일 때 사용하면 N+1 문제 해결할 수 있다.
  * 단점
    * 초기 쿼리 이외에 1+N/배치차이즈 만큼 추가 쿼리가 있다.
  
### 보완 후 테스트
* 보완 전 :게시글 10개, 고유 작성자 3명(A: 8개, B: 1개, C: 3개)일 경우, 총 1(게시글) + 1(카운트) + 3(작성자) = 5회의 쿼리 발생.
* Fetch Join 적용 후:
  * 데이터 조회 쿼리 (1회): JOIN을 통해 게시글과 작성자 정보를 한 번에 조회.
  * 카운트 쿼리 (1회): 페이징을 위한 count 쿼리.
  * 결과: 총 2회의 쿼리로 N+1 문제가 완벽하게 해결되었음을 SQL 로그를 통해 검증했습니다.

### 결과
* Fetch Join을 적용하여 게시판 목록 조회 시 발생하던 쿼리 실행 횟수를 5회에서 2회로 최적화했습니다. 
  이를 통해 불필요한 데이터베이스 부하를 줄이고 API 응답 시간을 단축하여 사용자 경험을 개선할 수 있었습니다. 
  또한, 다른 상세 페이지의 댓글 목록 조회 기능에도 Fetch Join을 적용하여 연관된 N+1 문제를 선제적으로 해결하고 애플리케이션의 전반적인 성능을 향상시켰습니다
